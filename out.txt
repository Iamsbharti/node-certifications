/**
 * IN NODE FILE -SYSTEMS IS MANAGED BY THESE MODULES
 * - FS // PROVIDES APIS TO DEAL WITH THE BUSINESS OF READING, WRITING,
 *      // FILE SYSTEM META-DATA AND FILE SYSTEM WATCHING.
 * - PATH //FOR PATH MANIPULATION AND NORMALIZATION ACROSS PLATFORMS
 */

/**
 * THESE 2 VARIABLES ARE PRESENT IN EVERY MODULE.
 * __FILENAME // HOLDS THE ABSOULTE PATH OF THE CURRENTLY EXECUTING FILE.
 * __DIRNAME // HOLDS THE ABSOLUTE PATH OF THE DIRECTORY THAT THE CURRENTLY EXECUTING FILE IS IN.
 */
"USE STRICT";
CONSOLE.LOG("PATH OF CEF::", __FILENAME); //-> /USERS/SAURABHBHARTI/DOCUMENTS/NODEJS_CERTIFICATION/FILESYSTEM.JS
CONSOLE.LOG("PATH OF CD::", __DIRNAME); // -> /USERS/SAURABHBHARTI/DOCUMENTS/NODEJS_CERTIFICATION

/**
 * FILE PATH CAN BE DIFFERENT IN WINDOWS AND POSIX[LINUX , MACOS] OS.
 * E.G.
 * - LINUX -> /TRAINING/CH-13/EXAMPLE.JS
 * - WIN -> C:\TRAINING\CH-13\EXAMPLE.JS
 * BACKSLASH IS THE ESCAPE CHARACTER IN JAVASCRIPT STRINGS.
 * SO TO REPRESENT IN WIN PATH SHOULD BE AS -> C:\\TRAINING\\CH-13\\EXAMPLE.JS
 *
 * THIS CAN BE RESOLVED BY USING JOIN METHOD OF PATH MODULE, WHICH HELP IN CROSS-ENV WORKINGS.
 */
CONST { JOIN } = REQUIRE("PATH");
CONSOLE.LOG("FILESYSTEMS PATH::USING JOIN::", JOIN(__DIRNAME, "FILESYSTEM.JS"));

/**
 * PATH.JOIN METHOD CAN BE PASSED AS MANY ARGUMENTS AS DESIRED. E.G. JOIN('ONE','TWO','THREE')
 * PATH.ISABSOLUTE WILL RETURN TRUE IF A GIVEN PATH IS ABSOLUTE.
 */
// ********** OTHER PATH BUILDERS ***************************** //
/**
 * PATH.RELATIVE -> GIVEN TWO ABSOLUTE PATHS, CALCULATES THE RELATIVE PATH BETWEEN THEM.
 *
 * PATH.RESOLVE -> ACCEPTS MULTIPLE STRING ARGUMENTS REPRESENTING PATHS.
 *  - RETURNS A STRING OF THE PATH THAT WOULD RESULT FROM NAVIGATING TO EACH OF THE DIRECTORIES
 *  - IN ORDER USING THE COMMAND LINE CD COMMAND.
 *  - PATH.RESOLVE('/FOO', 'BAR', 'BAZ')  // RETURNS '/FOO/BAR/BAZ'
 *      - WHICH IS AKIN TO EXECUTING CD /FOO THEN CD BAR THEN CD BAZ ON THE COMMAND LINE,
 *      - AND THEN FINDING OUT WHAT THE CURRENT WORKING DIRECTORY IS.
 *
 * PATH.NORMALIZE -> RESOLVES .. AND . DOT IN PATHS AND STRIPS EXTRA SLASHES.
 *  - PATH.NORMALIZE('/FOO/../BAR//BAZ') WOULD RETURN '/BAR/BAZ'.
 *
 * PATH.FORMAT -> BUILDS A STRING FROM AN OBJECT.
 */

// *************** PATH DECONSTRUCTORS **************************** //
CONST { PARSE, BASENAME, DIRNAME, EXTNAME } = REQUIRE("PATH");
CONSOLE.LOG("FILENAME PARSED:", PARSE(__FILENAME));
CONSOLE.LOG("FILENAME BASENAME:", BASENAME(__FILENAME));
CONSOLE.LOG("FILENAME DIRNAME:", DIRNAME(__FILENAME));
CONSOLE.LOG("FILENAME EXTNAME:", EXTNAME(__FILENAME));

// FOW WIN C:\\' WILL BE APPENDED FOR ROOT & DIR PROPERTY

// ******************* READING AND WRITING *********************** //
/**
 * FS MODULE HAS BOTH LOW AND HIGH LEVEL APIS.
 * THE LOWER LEVEL API'S CLOSELY MIRROR POSIX SYSTEM CALLS.
 * THE HIGHER LEVEL METHODS FOR READING AND WRITING ARE PROVIDED IN FOUR ABSTRACTION TYPES:
 *  - SYNCHRONOUS
 *  - CALLBACK BASED
 *  - PROMISE BASED
 *  - STREAM BASED
 */

// SYNCHRONOUS.
/**
 * ALL THE NAMES OF SYNCHRONOUS METHODS IN THE FS MODULE END WITH SYNC.
 * E.G. READFILESYNC
 */
CONST { READFILESYNC } = REQUIRE("FS");
CONST FILECONTENTS = READFILESYNC(__FILENAME);
// SYNCHRONOUSLY READ ITS OWN CONTENTS INTO A BUFFER AND THEN PRINT THE BUFFER:
CONSOLE.LOG("FILE CONTENTS SYNC BUFFER::", FILECONTENTS);

CONST FILECONTENTDECODED = READFILESYNC(JOIN(__DIRNAME, "OUTFILE"), {
  ENCODING: "UTF-8",
});
CONSOLE.LOG("FILE CONTENTS SYNC DECODED:", FILECONTENTDECODED);

// WRITE
CONST { WRITEFILESYNC } = REQUIRE("FS");
CONST CONTENTSUPPERCASE = READFILESYNC(JOIN(__DIRNAME, "OUTFILE"), {
  ENCODING: "UTF-8",
});
WRITEFILESYNC(JOIN(__DIRNAME, "OUTFILE"), CONTENTSUPPERCASE.TOUPPERCASE());
/**
 *  WRITEFILESYNC(JOIN(__DIRNAME, "OUT.TXT"), CONTENTSUPPERCASE.TOUPPERCASE(), {
      FLAG: "A",
    });
    -> FLAG :"A" OPENS FILE IN APPEND MODE
 */

// ERROR HANDLING CAN BE ACHIEVED USING TRY/CATCH FOR SYNCHRONOUS BASED APIS.

// CALLBACK BASED
CONST { READFILE } = REQUIRE("FS");
READFILE(JOIN(__DIRNAME, "OUTFILE"), { ENCODING: "UTF-8" }, (ERR, CONTENTS) => {
  IF (ERR) {
    CONSOLE.LOG("ERROR WHILE READING FILE");
  } ELSE {
    CONSOLE.LOG("FILE READ VIA CALLBACK::", CONTENTS);
  }
});

/**
 * HOWEVER, THE ACTUAL BEHAVIOR OF THE I/O OPERATION AND THE JAVASCRIPT ENGINE IS DIFFERENT.
 * IN THE READFILESYNC CASE EXECUTION IS PAUSED UNTIL THE FILE HAS BEEN READ, WHEREAS
 * IN THIS EXAMPLE EXECUTION IS FREE TO CONTINUE WHILE THE READ OPERATION IS PERFORMED.
 * ONCE THE READ OPERATION IS COMPLETED, THEN THE CALLBACK FUNCTION THAT WE PASSED AS
 * THE THIRD ARGUMENT TO READFILE IS CALLED WITH THE RESULT. THIS ALLOWS FOR THE
 * PROCESS TO PERFORM OTHER TASKS (ACCEPTING AN HTTP REQUEST FOR INSTANCE).
 */

// PROMISE BASED
/** 
    CONST { READFILE, WRITEFILE } = REQUIRE("FS").PROMISES;
    ASYNC FUNCTION RUN() {
    CONST CONTENTS = AWAIT READFILE(__FILENAME, { ENCODING: "UTF8" });
    CONST OUT = JOIN(__DIRNAME, "OUT.TXT");
    AWAIT WRITEFILE(OUT, CONTENTS.TOUPPERCASE());
    }

    RUN().CATCH(CONSOLE.ERROR);
*/

// STREAM BASED
/**
 * THE FS MODULE HAS FS.CREATEREADSTREAM AND FS.CREATEWRITESTREAM METHOD FOR THE SAME.
 * USEFUL FOR LARGE SIZE FILES.
 */
CONST { PIPELINE } = REQUIRE("STREAM");
CONST { CREATEREADSTREAM, CREATEWRITESTREAM } = REQUIRE("FS");
CONST { TRANSFORM } = REQUIRE("STREAM");
CONST CREATEUPPERCASESTREAM = () => {
  RETURN NEW TRANSFORM({
    TRANSFORM(CHUNK, ENC, NEXT) {
      CONST UPPERCASED = CHUNK.TOSTRING().TOUPPERCASE();
      NEXT(NULL, UPPERCASED);
    },
  });
};

PIPELINE(
  CREATEREADSTREAM(__FILENAME),
  CREATEUPPERCASESTREAM(),
  CREATEWRITESTREAM(JOIN(__DIRNAME, "OUT.TXT")),
  (ERR) => {
    IF (ERR) {
      CONSOLE.ERROR(ERR);
      RETURN;
    }
    CONSOLE.LOG("FINISHED WRITING");
  }
);

//************************** READING DIRECTORIES *************************/
/**
 * DIRECTORIES ARE SPECIAL TYPE OF FILE, WHICH HOLDS A CATALOGE OF FILES.
 * SIMILAR TO FILES FS PROVIDES MULTIPLE WAYS TO READ A DIRECTORY.
 * 
 *  - SYNCHRONOUS
    - CALLBACK-BASED
    - PROMISE-BASED
    - AN ASYNC ITERABLE THAT INHERITS FROM FS.DIR
 * 
 */
CONST { READDIRSYNC, READDIR } = REQUIRE("FS");
CONST { READDIR: READDIRPROM } = REQUIRE("FS").PROMISES;
// SYNCHRONOUS
TRY {
  CONSOLE.LOG("SYNC DIR::", READDIRSYNC(__DIRNAME));
} CATCH (ERROR) {
  CONSOLE.LOG("ERROR READING DIR::", ERROR);
}
// CALLBACK BASED
READDIR(__DIRNAME, (ERROR, FILES) => {
  IF (ERROR) {
    CONSOLE.LOG("ERROR READING DIR CALLBACK::", ERROR);
  } ELSE {
    CONSOLE.LOG("READ DIR CALLBACK::", FILES);
  }
});
// ASYNC
ASYNC FUNCTION FOORUN() {
  CONST FILES = AWAIT READDIRPROM(__DIRNAME);
  CONSOLE.LOG("ASYNC DIR READ::", FILES);
}
FOORUN().CATCH((ERROR) => CONSOLE.LOG("ERROR READING DIR ASYNC::", ERROR));

/**
 * FOR EXTREMLY LARGE DIRECTORIES:
 * - FS.OPENDIR ,FS.OPENDIRSYNC OR FS.PROMISES.OPENDIR CAN BE USED TO READ AS STREAMS.
 * - THESE METHODS PROVIDES A STREAM-LIKE INTERFACE THAT WE CAN PASS TO READABLE.FROM TO TURN IT INTO A STREAM
 */
/** 
  CONST { CREATESERVER } = REQUIRE("HTTP");
  CONST { READABLE } = REQUIRE("STREAM");
  CONST { OPENDIR } = REQUIRE("FS");

  CONST CREATEENTRYSTREAM = () => {
    LET SYNTAX = "[\N";
    RETURN NEW TRANSFORM({
      WRITABLEOBJECTMODE: TRUE,
      READABLEOBJECTMODE: FALSE,
      TRANSFORM(ENTRY, ENC, NEXT) {
        NEXT(NULL, `${SYNTAX} "${ENTRY.NAME}"`);
        SYNTAX = ",\N";
      },
      FINAL(CB) {
        THIS.PUSH("\N]\N");
        CB();
      },
    });
  };

  CREATESERVER((REQ, RES) => {
    IF (REQ.URL !== "/") {
      RES.STATUSCODE = 404;
      RES.END("NOT FOUND");
      RETURN;
    }
    OPENDIR(__DIRNAME, (ERR, DIR) => {
      IF (ERR) {
        RES.STATUSCODE = 500;
        RES.END("SERVER ERROR");
        RETURN;
      }
      CONST DIRSTREAM = READABLE.FROM(DIR);
      CONST ENTRYSTREAM = CREATEENTRYSTREAM();
      RES.SETHEADER("CONTENT-TYPE", "APPLICATION/JSON");
      PIPELINE(DIRSTREAM, ENTRYSTREAM, RES, (ERR) => {
        IF (ERR) CONSOLE.ERROR(ERR);
      });
    });
  }).LISTEN(3000);
*/
// ******************** FILES METADATA *******************************//
/**
 * METADATA OF FILES CAN BE FOUND USING THESE METHODS::
 * - FS.STAT, FS.STATSYNC, FS.PROMISES.STAT
 * - FS.LSTAT, FS.LSTATSYNC, FS.PROMISES.LSTAT
 *
 * DIFFERENCE BETWEEN STAT AND LSTAT METHODS IS THAT
 * - STAT FOLLOWS SYMBOLIC LINKS, AND
 * - LSTAT WILL GET META DATA FOR SYMBOLIC LINKS INSTEAD OF FOLLOWING THEM.
 *
 * THESE METHODS RETURN AN FS.STAT INSTANCE WHICH HAS A VARIETY OF PROPERTIES AND
 * METHODS FOR LOOKING UP METADATA ABOUT A FILE.
 */
CONST { STATSYNC } = REQUIRE("FS");
CONST FILES = READDIRSYNC(__DIRNAME);
FOR (LET FILE OF FILES) {
  CONST STAT = STATSYNC(FILE);
  CONSOLE.LOG("FILE TYPELABEL::", STAT.ISDIRECTORY() ? "DIR" : "FILE", FILE);
}
/**
 * THERE ARE FOUR STATS AVAILABLE FOR FILES:
   - ACCESS TIME
   - CHANGE TIME
   - MODIFIED TIME
   - BIRTH TIME
 * THE DIFFERENCE BETWEEN CHANGE TIME AND "MODIFIED" TIME, IS MODIFIED TIME ONLY APPLIES TO WRITES.
 * WHEREAS "CHANGE" TIME APPLIES TO WRITES AND ANY STATUS CHANGES SUCH AS CHANGING PERMISSIONS OR OWNERSHIP.
 * WITH DEFAULT OPTIONS, THE TIME STATS ARE OFFERED IN TWO FORMATS: 
 * - DATE OBJECT 
 * - MILLISECONDS SINCE THE EPOCH.
 */
// PRINT FILE TIME METADATA
FOR (CONST FILE OF FILES) {
  CONST STAT = STATSYNC(FILE);
  CONST TYPELABEL = STAT.ISDIRECTORY() ? "DIR" : "FILE";
  CONST { ATIME, MTIME, CTIME, BIRTHTIME } = STAT;
  CONSOLE.GROUP(TYPELABEL, FILE);
  CONSOLE.LOG("ACCESS TIME::", ATIME.TOLOCALEDATESTRING());
  CONSOLE.LOG("MODIFIED TIME::", MTIME.TOLOCALETIMESTRING());
  CONSOLE.LOG("CHANGE TIME::", CTIME.TOLOCALEDATESTRING());
  CONSOLE.LOG("BIRTHTIME::", BIRTHTIME.TOLOCALETIMESTRING());
  CONSOLE.GROUPEND();
  CONSOLE.LOG();
}

/******************** FILE WATCHING  ********************************/
/**
 * FS.WATCH METHOD IS PROVIDED BY NODE CORE TO TAP INTO FILE SYSTEM EVENTS.
 * IT'S A LOW LEVEL API, FOR PRODUCTION OR MORE USER FRIENDLY USE CHOKIDAR.
 *
 */
CONST { WATCH } = REQUIRE("FS");
WATCH(".", (EVENT, FILENAME) => {
  CONSOLE.LOG("WATCHER::", EVENT, FILENAME);
});
