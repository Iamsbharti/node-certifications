/**
 * IN NODE FILE -SYSTEMS IS MANAGED BY THESE MODULES
 * - FS // PROVIDES APIS TO DEAL WITH THE BUSINESS OF READING, WRITING,
 *      // FILE SYSTEM META-DATA AND FILE SYSTEM WATCHING.
 * - PATH //FOR PATH MANIPULATION AND NORMALIZATION ACROSS PLATFORMS
 */

/**
 * THESE 2 VARIABLES ARE PRESENT IN EVERY MODULE.
 * __FILENAME // HOLDS THE ABSOULTE PATH OF THE CURRENTLY EXECUTING FILE.
 * __DIRNAME // HOLDS THE ABSOLUTE PATH OF THE DIRECTORY THAT THE CURRENTLY EXECUTING FILE IS IN.
 */
"USE STRICT";
CONSOLE.LOG("PATH OF CEF::", __FILENAME); //-> /USERS/SAURABHBHARTI/DOCUMENTS/NODEJS_CERTIFICATION/FILESYSTEM.JS
CONSOLE.LOG("PATH OF CD::", __DIRNAME); // -> /USERS/SAURABHBHARTI/DOCUMENTS/NODEJS_CERTIFICATION

/**
 * FILE PATH CAN BE DIFFERENT IN WINDOWS AND POSIX[LINUX , MACOS] OS.
 * E.G.
 * - LINUX -> /TRAINING/CH-13/EXAMPLE.JS
 * - WIN -> C:\TRAINING\CH-13\EXAMPLE.JS
 * BACKSLASH IS THE ESCAPE CHARACTER IN JAVASCRIPT STRINGS.
 * SO TO REPRESENT IN WIN PATH SHOULD BE AS -> C:\\TRAINING\\CH-13\\EXAMPLE.JS
 *
 * THIS CAN BE RESOLVED BY USING JOIN METHOD OF PATH MODULE, WHICH HELP IN CROSS-ENV WORKINGS.
 */
CONST { JOIN } = REQUIRE("PATH");
CONSOLE.LOG("FILESYSTEMS PATH::USING JOIN::", JOIN(__DIRNAME, "FILESYSTEM.JS"));

/**
 * PATH.JOIN METHOD CAN BE PASSED AS MANY ARGUMENTS AS DESIRED. E.G. JOIN('ONE','TWO','THREE')
 * PATH.ISABSOLUTE WILL RETURN TRUE IF A GIVEN PATH IS ABSOLUTE.
 */
// ********** OTHER PATH BUILDERS ***************************** //
/**
 * PATH.RELATIVE -> GIVEN TWO ABSOLUTE PATHS, CALCULATES THE RELATIVE PATH BETWEEN THEM.
 *
 * PATH.RESOLVE -> ACCEPTS MULTIPLE STRING ARGUMENTS REPRESENTING PATHS.
 *  - RETURNS A STRING OF THE PATH THAT WOULD RESULT FROM NAVIGATING TO EACH OF THE DIRECTORIES
 *  - IN ORDER USING THE COMMAND LINE CD COMMAND.
 *  - PATH.RESOLVE('/FOO', 'BAR', 'BAZ')  // RETURNS '/FOO/BAR/BAZ'
 *      - WHICH IS AKIN TO EXECUTING CD /FOO THEN CD BAR THEN CD BAZ ON THE COMMAND LINE,
 *      - AND THEN FINDING OUT WHAT THE CURRENT WORKING DIRECTORY IS.
 *
 * PATH.NORMALIZE -> RESOLVES .. AND . DOT IN PATHS AND STRIPS EXTRA SLASHES.
 *  - PATH.NORMALIZE('/FOO/../BAR//BAZ') WOULD RETURN '/BAR/BAZ'.
 *
 * PATH.FORMAT -> BUILDS A STRING FROM AN OBJECT.
 */

// *************** PATH DECONSTRUCTORS **************************** //
CONST { PARSE, BASENAME, DIRNAME, EXTNAME } = REQUIRE("PATH");
CONSOLE.LOG("FILENAME PARSED:", PARSE(__FILENAME));
CONSOLE.LOG("FILENAME BASENAME:", BASENAME(__FILENAME));
CONSOLE.LOG("FILENAME DIRNAME:", DIRNAME(__FILENAME));
CONSOLE.LOG("FILENAME EXTNAME:", EXTNAME(__FILENAME));

// FOW WIN C:\\' WILL BE APPENDED FOR ROOT & DIR PROPERTY

// ******************* READING AND WRITING *********************** //
/**
 * FS MODULE HAS BOTH LOW AND HIGH LEVEL APIS.
 * THE LOWER LEVEL API'S CLOSELY MIRROR POSIX SYSTEM CALLS.
 * THE HIGHER LEVEL METHODS FOR READING AND WRITING ARE PROVIDED IN FOUR ABSTRACTION TYPES:
 *  - SYNCHRONOUS
 *  - CALLBACK BASED
 *  - PROMISE BASED
 *  - STREAM BASED
 */

// SYNCHRONOUS.
/**
 * ALL THE NAMES OF SYNCHRONOUS METHODS IN THE FS MODULE END WITH SYNC.
 * E.G. READFILESYNC
 */
CONST { READFILESYNC } = REQUIRE("FS");
CONST FILECONTENTS = READFILESYNC(__FILENAME);
// SYNCHRONOUSLY READ ITS OWN CONTENTS INTO A BUFFER AND THEN PRINT THE BUFFER:
CONSOLE.LOG("FILE CONTENTS SYNC BUFFER::", FILECONTENTS);

CONST FILECONTENTDECODED = READFILESYNC(JOIN(__DIRNAME, "OUTFILE"), {
  ENCODING: "UTF-8",
});
CONSOLE.LOG("FILE CONTENTS SYNC DECODED:", FILECONTENTDECODED);

// WRITE
CONST { WRITEFILESYNC } = REQUIRE("FS");
CONST CONTENTSUPPERCASE = READFILESYNC(JOIN(__DIRNAME, "OUTFILE"), {
  ENCODING: "UTF-8",
});
WRITEFILESYNC(JOIN(__DIRNAME, "OUTFILE"), CONTENTSUPPERCASE.TOUPPERCASE());
/**
 *  WRITEFILESYNC(JOIN(__DIRNAME, "OUT.TXT"), CONTENTSUPPERCASE.TOUPPERCASE(), {
      FLAG: "A",
    });
    -> FLAG :"A" OPENS FILE IN APPEND MODE
 */

// ERROR HANDLING CAN BE ACHIEVED USING TRY/CATCH FOR SYNCHRONOUS BASED APIS.

// CALLBACK BASED
CONST { READFILE } = REQUIRE("FS");
READFILE(JOIN(__DIRNAME, "OUTFILE"), { ENCODING: "UTF-8" }, (ERR, CONTENTS) => {
  IF (ERR) {
    CONSOLE.LOG("ERROR WHILE READING FILE");
  } ELSE {
    CONSOLE.LOG("FILE READ VIA CALLBACK::", CONTENTS);
  }
});

/**
 * HOWEVER, THE ACTUAL BEHAVIOR OF THE I/O OPERATION AND THE JAVASCRIPT ENGINE IS DIFFERENT.
 * IN THE READFILESYNC CASE EXECUTION IS PAUSED UNTIL THE FILE HAS BEEN READ, WHEREAS
 * IN THIS EXAMPLE EXECUTION IS FREE TO CONTINUE WHILE THE READ OPERATION IS PERFORMED.
 * ONCE THE READ OPERATION IS COMPLETED, THEN THE CALLBACK FUNCTION THAT WE PASSED AS
 * THE THIRD ARGUMENT TO READFILE IS CALLED WITH THE RESULT. THIS ALLOWS FOR THE
 * PROCESS TO PERFORM OTHER TASKS (ACCEPTING AN HTTP REQUEST FOR INSTANCE).
 */

// PROMISE BASED
/** 
    CONST { READFILE, WRITEFILE } = REQUIRE("FS").PROMISES;
    ASYNC FUNCTION RUN() {
    CONST CONTENTS = AWAIT READFILE(__FILENAME, { ENCODING: "UTF8" });
    CONST OUT = JOIN(__DIRNAME, "OUT.TXT");
    AWAIT WRITEFILE(OUT, CONTENTS.TOUPPERCASE());
    }

    RUN().CATCH(CONSOLE.ERROR);
*/

// STREAM BASED
/**
 * THE FS MODULE HAS FS.CREATEREADSTREAM AND FS.CREATEWRITESTREAM METHOD FOR THE SAME.
 * USEFUL FOR LARGE SIZE FILES.
 */
CONST { PIPELINE } = REQUIRE("STREAM");
CONST { CREATEREADSTREAM, CREATEWRITESTREAM } = REQUIRE("FS");
CONST { TRANSFORM } = REQUIRE("STREAM");
CONST CREATEUPPERCASESTREAM = () => {
  RETURN NEW TRANSFORM({
    TRANSFORM(CHUNK, ENC, NEXT) {
      CONST UPPERCASED = CHUNK.TOSTRING().TOUPPERCASE();
      NEXT(NULL, UPPERCASED);
    },
  });
};

PIPELINE(
  CREATEREADSTREAM(__FILENAME),
  CREATEUPPERCASESTREAM(),
  CREATEWRITESTREAM(JOIN(__DIRNAME, "OUT.TXT")),
  (ERR) => {
    IF (ERR) {
      CONSOLE.ERROR(ERR);
      RETURN;
    }
    CONSOLE.LOG("FINISHED WRITING");
  }
);
